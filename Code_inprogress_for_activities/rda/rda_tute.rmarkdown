---
title: "RDA_tutorial"
execute:
  output: false
---


## Undertaking Redundancy Analyses

### Tutorial based on "RDA applications in landscape genomics, by Thibaut Capblancq & Brenna Forester, 2021

The original tutorial can be found on [GitHub](https%20cape-genomics) and shows how to locate and prepare original data files.

This 2023 update uses files that have been compiled and tidied. Much of the code is also updated to make use of `sf` and `terra` but some of the code is from the original tutorial.

Original comments by Capblancq & Forester will be indented

> like this!

## Introduction

> This tutorial provides code and explanation associated with a review of the different applications of RDA in the field of landscape genomics written by Thibaut Capblancq & Brenna Forester (2021) Redundancy Analysis (RDA): a Swiss-army knife for landscape genomics.

> We highly recommend the following book for those interested in RDA: Borcard D, Gillet F, Legendre P (2018) Numerical Ecology with R, 2nd edition.

(Cynthia also endorses the same book)

### Datafiles

#### Climatic variables

> The values of 27 bioclimate variables were extracted for all 281 populations from the [ClimateNA database](http://www.climatena.ca) for the period 1961-1990, and projections for 2050 and 2080. The projections are based on an [ensemble of 15 AOGCMs using CMIP5](https://adaptwest.databasin.org/pages/adaptwest-climatena-cmip5/).

These data have been compiled and projected into the WGS84 reference coordinate system following instructions from Capblancq & Forester and saved as a spatial raster.

-   `ras_6190.rast` = present day

#### Population allele frequencies

Original genetic data and metadata from Mahony et al. 2019, available [here](https://datadryad.org/stash/dataset/doi:10.5061/dryad.56j8vq8).

Pre-processing:

-   Called genotypes were recoded as numeric in order to run RDA using the `vegan` library. Although some other packages will conduct PCAs and RDAs, `vegan` is recommended. In the numeric formatting, 0 represents an individual homozygous for the major allele, 1 represents a heterozygote, and 2 is homozygous for the alternative allele.
-   Dataframes were subset to individuals with spatially relevant metadata.
-   The mean allele frequency per population (281 populations) was computed
-   Loci with missing data from 12 or more populations were excluded
-   For population-by-locus combinations with NA values, the values were imputed as the median across all populations (cannot have missing data for PCA and RDA)
-   MAFs \< 0.05 or \> 0.95 were excluded from full SNP data set (but not "neutral" SNPs)
- *When is genetic data scaled?*

Datafiles

-   `AllFreq`: 281 populations, 28658 loci
-   `AllFreq_neutral`: 281 populations, 3936 loci
-   `PlSeedlots.csv`: the geographic coordinates of each source population.

Look at all these files using tools and techniques that you have learned. What is in the `ras_6190.rast` object? (try plotting it)

Some comments from C & F: 

> An RDA model can either be conducted with individual-based genotypes (0, 1, 2 format) or population-based allele frequencies (ranging from 0 to 1). We decided here to work with allele frequencies for the main reason that several individuals were genotyped at each sampling site (i.e., source population) and experienced the exact same climatic conditions. Plus, the sample sizes varied across populations.

> (For full data set) SNPs with a minor allele frequency inferior to 5% were filtered out to avoid giving too much importance to rare alleles when looking for loci associated with environmental variation. Doing so means assuming that local adaptation is driven by consequent changes in adaptive allele frequency along environmental gradients.

> (For neutral data set) No filtering on MAF was applied here because small genetic variations are expected to be involved in differentiating neutral genetic groups.

Load libraries and data files


```{r load libraries and data files}
library(terra)
library(vegan)


load("./data/ras_6190_SpatRast.RData")
AllFreq<-read.table("./data/AllFreq2_pine_RDAtutorial.txt", header = T)
Neutral<-read.table("./data/AllFreqNeutral_pine_RDAtutorial.txt", header = T)
Coordinates <- read.table("./data/PlSeedlots.csv", sep = ",", header = T, row.names = 1)

# Tidy up the coordinates data and check them
Coordinates <- Coordinates[match(row.names(AllFreq), Coordinates$id2, nomatch = 0),]
colnames(Coordinates) <- c("Population", "Latitude", "Longitude", "Elevation")
Coordinates[1:5,]
```


## Preparing data for RDA

A series of RDAs will be the heart of the analyses. Before you can do an RDA, however, you need to have all your data prepared and organised. The genetic data is already largely prepared, but some extra work is needed for the environmental data and for estimating neutral population structure.

### Extract environmental data from rasters and scale it

```{r Extract environmental data from rasters}
Env<-terra::extract(ras_6190.rast, Coordinates[,3:2])
#Env_orig <- data.frame(extract(ras_6190, Coordinates[,3:2]))

# look at your extracted data
Env[1:5,1:8]

Env <- scale(Env, center=TRUE, scale=TRUE) # center=TRUE, scale=TRUE are the defaults for scale()

row.names(Env) <- c(Coordinates$Population)

#CR - might need to get rid of first column
```



### Use "neutral" SNPs to estimate population structure

> To account for population structure in some of the following RDA-based procedures we conducted a principal component analysis (PCA) on the set of 3,934 intergenic SNPs and retained the first three PCs as proxy of population evolutionary history.


```{r pca of neutral markers }
## Running a PCA on neutral genetic markers
pca <- rda(AllFreq_neutral[,-1], scale=T) # PCA in vegan uses the rda() call without any predictors
# scale = T will take care of scaling for you

# look at screeplot to decide importance
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")

```


Examine the `pca` object (call `pca` and `summary(pca)`) - think about how many PC's are informative. When you call `pca` you will see the formula, the "Inertia" and the Eigenvalues for the PC axes. Notice that all the Inertia is unconstrained. Later you will compare this to the full RDA output. Divide the Eigenvalue of PC1 but the total Inertia: this will be percent of variance explained by PC1. The "Species scores" are your column variables, which are loci in this case. The "Site scores" are row variables or populations. The values are loadings, which enable you to plot loci or populations in PC space. 

If this were my data and analysis, I would plot the PCA at this point and make sure it all made sense. 


```{r plot pca or rda}

biplot(pca, choices=c(1,2), scaling = "symmetric", type= c("points", "text"))
```


What I like to see in a pca is balanced clouds of points. If there is very little population structure, you might see one big cloud of points. If you have substantial structuring, there could be multiple clouds of points. Smears along a single axis (as we see here) are a bit worrisome especially if they do not make geographical sense. Another attribute to be aware of is that imputing allele frequencies can pull values to the middle. For the purposes of this tutorial, we will just continue, but in a real analysis I would try to understand my data at this point and make sure that there are no odd dynamics that might influence later analyeses.

People often use screeplots to look at variance and decide on the number of PCs to keep.


```{r screeplot of pca }
# look at screeplot to decide importance
screeplot(pca, type = "barplot", npcs=10, main="PCA Eigenvalues")

```



> Based on the screeplot, two or three PCs would be a reasonable set to retain as a proxy for neutral population structure in downstream analyses. In this case, we decided to keep the first three PCs. 

Values from these first three PCs can now be extracted. It can be very useful to construct a dataframe containing all the spatial predictors. That's the strategy that C & F follow: 


```{r pull out neutral pca scores}
PCs <- scores(pca, choices=c(1:3), display="sites", scaling=0)
PopStruct <- data.frame(Population = AllFreq_neutral[,1], PCs)
colnames(PopStruct) <- c("Population", "PC1", "PC2", "PC3")

#check the object 
PopStruct[1:5,]
```


Note that PC eigenvectors will already be scaled. You can test this using `sum(PopStruct$PC1)`. There might be a small value due to rounding error but it will be very small. 



### To add - MEMS

## Building a full RDA model for environmental variables with forward selection

> Forward selection starts from a "null" model where the response is explained only by an intercept. Variables are then added to the model one by one to try to reach the amount of variance explained by a "full" model (i.e., model including all the explanatory variables), while limiting the amount of redundancy among included variables.

Whether forward selection is the best approach or not is debatable, but it is the most common procedure for dealing with multiple variables. To do this, you first build the intercept only model and then define a full model. 


```{r build full model}
## Null model
RDA0 <- rda(AllFreq ~ 1,  Variables) 

## Full model
RDAfull <- rda(AllFreq ~ AHM + bFFP + CMD + DD_0 + DD_18 + DD18 + DD5 + eFFP + EMT + Eref + EXT + FFP + MAP + MAR + MAT + MCMT + MSP + MWMT + NFFD + PAS + PPT_sm + PPT_wt + RH + SHM + Tave_sm + Tave_wt + TD, Variables)
```


Examine the structure of `RDA0` by just typing `RDA0` and also `summary(RDA0)`. There is a lot of information but the structure is essentially a PCA, since we did not define any explanatory variables. As before, the "Species scores" are your column variables, which are loci in this case. The "Site scores" are row variables or populations. 

Once you have looked at `RDA0`, take a look at `RDAfull`. Now you will see *constrained* inertia that represents the variance explained by your predictor variables. (Notice that most variance remains unconstrained, this is quite common). Remember that the predictor variables have now been ordinated as RDA eigenvectors where each RDA axis is orthogonal to the others. The eigenvalues represent how much variance in reponse variables (allele frequencies) is predicted by that eigenvector, e.g., RDA1 predicts 29.4/578 percent of the variance in allele frequencies. 

The last table in `summary(RDAfull)` shows how the different environmental variables load onto each RDA axis. 

To make a quick plot of your RDA, now use `ordiplot`. This will make a biplot that combines your populations (points) and predictor variables (arrows).


```{r}
ordiplot(RDAfull)
```


The `vegan` package is very well documented and it is worth spending time learning some of the options if you are going to be using ordination in your toolbox of analyses.

> To conduct the selection procedure we used the ordiR2step function of the package vegan and the following stopping criteria: variable significance of p \< 0.01 using 1000 permutations, and the adjusted R2 of the global model.

Because this command will take a long time to run, I suggest that you start it and watch what it is doing, but I have saved the output `mod` for you to import, so you can stop the process to speed things up.


```{r ordistep for environmental data}
#| eval: false

## Stepwise procedure with ordiR2step function
mod <- ordiR2step(RDA0, RDAfull, Pin = 0.01, R2permutations = 1000, R2scope = T)
#this takes a while to run - interupt it after a few minutes 
```


Load the output of the full ordiR2step

```{r load mod}
# load the output
load("./data/mod.Rdata")
```


As before, examine the `mod` object in detail. 

> In total, nine of the 27 bioclimate variables were selected: MAR, EMT, MWMT, CMD, Tave_wt, DD_18, MAP, Eref and PAS.

> **Notes on interpretation and best practices:** We remind users that this predictive approach to variable selection optimizes the variance explained, but does not necessarily identify the ecological or mechanistic drivers of genetic variation. Additionally, pairwise predictor correlations can be very high, e.g., among seasonal calculations of temperature or precipitation. While one variable may maximize variance explained, it may be another, correlated variable, potentially even unmeasured, that is the mechanistic driver of variation. The ubiquitous nature of environmental correlation means that it is critical to carefully investigate selected variables but also avoid overinterpretation of variable importance in downstream analyses unless mechanistic data support observed relationships.


# Points for class discussion

1.  Thoughts on the filtering and preprocessing of genetic data? Could there be unintentional biases?

2.  RDAs can be undertaken on either population allele frequencies or individual genotypes. When would it be strategic to pick one over the other? Are there any special considerations with either data type?

3.  Notice that this tutorial does not look for correlations among environmental variables. What arguments can you make for or against reducing your environmental variables using approaches life *variance inflation factors*? Would you look at correlations across your whole landscape or across your study sites only?

